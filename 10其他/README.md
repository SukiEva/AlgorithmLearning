# 补充知识

### 1、typedef 和 define

- typedef 定义别名
  - typedef long long ll
    - ll 是 long long 的别名
- define 替换
  - define ll long long
    - 用 long long 替换 ll

### 2、malloc 和 new

new 和 malloc 的区别可以从以下几方面进行阐述:

- 最大的区别：
  - new 在申请空间的时候会调用构造函数
  - malloc 不会调用
- 释放空间：
  - malloc 用 free
  - new 用 delete
- 申请失败返回：
  - new 在申请空间失败后返回的是错误码 bad_alloc
  - malloc 在申请空间失败后会返回 NULL
- 属性上：
  - new/delete 是 C++关键字需要编译器支持
  - maollc 是库函数，需要添加头文件
- 参数：
  - new 在申请内存分配时不需要指定内存块大小，编译器会更具类型计算出大小
  - malloc 需要显示的指定所需内存的大小
- 成功返回类型：
  - new 操作符申请内存成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，因此 new 是类型安全性操作符。
  - malloc 申请内存成功则返回 void\*，需要强制类型转换为我们所需的类型
- 自定义类型：
  - new 会先调 operator new 函数，申请足够的内存（底层也是 malloc 实现），然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete 先调用析构函数，然后调用 operator delete 函数来释放内存（底层是通过 free 实现）。
  - malloc/free 是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数
- 重载：
  - C++允许重载 new/delete 操作符，特别的，布局 new 的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new 在这段内存上为对象调用构造函数完成初始化工作，并返回地址。
  - malloc 不允许重载。

### 3、指针(\*)和引用(&)

- 指针从本质上讲是一个变量，变量的值是另一个变量的地址，它可以被改变的，包括指针变量的值（所指向的地址）和指针变量的值对应的内存中的数据（所指向地址中所存放的数据）。
- 引用从本质上讲是一个别名，所以引用必须在一开始就被初始化（先有变量，才能有别名），而且其引用的对象在其整个生命周期中不能被改变，即自始至终只能依附于同一个变量。

**参数传递：**
- 指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
- 引用传递过程中，被调函数的形式参数虽然同样作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
- 值传递时函数操作的并不是实参本身，形参和实参是相互独立的，所以对形参进行操作并不会改变实参的值。
引用传递操作地址是实参地址 ，形参相当于实参的一个别名，对它的操作就是对实参的操作。
指针传递时，可以通过指针操作实参，同样可以改变实参的值。